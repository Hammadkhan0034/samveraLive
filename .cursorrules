# Next.js 16 Cursor Rules

## Project Overview
This is a Next.js 16 application using the App Router, TypeScript, Tailwind CSS, and Supabase. Follow these rules for all code generation and modifications.

## Core Principles

### 1. Component/Module-First Approach
- **Always** organize code by feature/domain first, then by type
- Prefer colocation: keep related files (components, hooks, utils, types) together
- Use the `app/` directory structure for routes and layouts
- Use `components/` directory for reusable UI components
- Use `lib/` directory for utilities, hooks, and shared logic
- Group related functionality in feature-based modules

### 2. Shared Components
- **Always** check `app/components/shared/` before creating new components
- Extract common UI patterns into shared components
- Shared components should be:
  - Generic and reusable
  - Well-typed with TypeScript
  - Documented with JSDoc comments
  - Located in `app/components/shared/`
- Examples of shared components: buttons, inputs, modals, cards, loading states, error boundaries

### 3. Next.js 16 Best Practices

#### App Router Structure
- Use Server Components by default (React Server Components)
- Only use `'use client'` directive when necessary (interactivity, hooks, browser APIs)
- Leverage Server Actions for mutations instead of API routes when possible
- Use Route Handlers (`route.ts`) for external API integrations or webhooks
- Implement proper loading states with `loading.tsx`
- Use `error.tsx` for error boundaries
- Leverage `not-found.tsx` for 404 handling

#### File Naming Conventions
- Use `page.tsx` for route pages
- Use `layout.tsx` for layouts
- Use `loading.tsx` for loading states
- Use `error.tsx` for error boundaries
- Use `not-found.tsx` for 404 pages
- Use `route.ts` for API route handlers
- Use `component.tsx` or `Component.tsx` for components (PascalCase)
- Use `hook.ts` or `useHook.ts` for custom hooks
- Use `util.ts` or `utils.ts` for utility functions
- Use `type.ts` or `types.ts` for TypeScript types

#### Server Components (Default)
- Prefer Server Components for:
  - Data fetching
  - Accessing backend resources
  - Keeping sensitive information on the server
  - Large dependencies (reduce client bundle)
  - Static content
- Server Components can:
  - Directly access databases, file systems, etc.
  - Use async/await for data fetching
  - Import Server-only modules

#### Client Components
- Only use `'use client'` when you need:
  - React hooks (useState, useEffect, useContext, etc.)
  - Browser APIs (window, document, localStorage, etc.)
  - Event listeners (onClick, onChange, etc.)
  - Third-party libraries that require client-side JavaScript
- Keep Client Components small and focused
- Pass data from Server Components to Client Components as props
- Use Server Actions for mutations from Client Components

#### Data Fetching
- Use async Server Components for data fetching
- Use `fetch` with Next.js caching by default
- Configure caching with `cache: 'no-store'` for dynamic data
- Use `revalidate` for ISR (Incremental Static Regeneration)
- Use `generateStaticParams` for dynamic routes
- Prefer Server Actions over API routes for mutations

#### Server Actions
- Define Server Actions in `lib/server-actions.ts` or colocated `actions.ts` files
- Use `'use server'` directive at the top of Server Action files
- Validate inputs with Zod schemas
- Handle errors gracefully with try-catch
- Return proper error messages to the client

#### TypeScript
- Use strict TypeScript configuration
- Define types in `lib/types/` directory
- Use interfaces for object shapes
- Use types for unions, intersections, and computed types
- Avoid `any` - use `unknown` if type is truly unknown
- Use type inference where possible
- Export types from a central `types.ts` file per module

#### Styling
- Use Tailwind CSS utility classes
- Prefer Tailwind over custom CSS
- Use CSS modules only when necessary for component-scoped styles
- Use `globals.css` for global styles only
- Follow mobile-first responsive design
- Use Tailwind's dark mode utilities when applicable

#### Performance
- Use `next/image` for all images
- Use `next/link` for client-side navigation
- Implement proper code splitting
- Use dynamic imports (`next/dynamic`) for heavy components
- Optimize fonts with `next/font`
- Use React Server Components to reduce bundle size
- Implement proper loading states
- Use Suspense boundaries for async components

#### Error Handling
- Use error boundaries (`error.tsx`) for route-level errors
- Handle errors in Server Actions with try-catch
- Provide user-friendly error messages
- Log errors appropriately (server-side)
- Use proper HTTP status codes in API routes

#### Security
- Never expose sensitive data to Client Components
- Validate all user inputs with Zod
- Use Server Actions for mutations (CSRF protection built-in)
- Sanitize user inputs
- Use environment variables for secrets (never commit)
- Implement proper authentication checks in Server Components

## File Organization

### Directory Structure
```
app/
  ├── (routes)/          # Route groups
  │   ├── page.tsx
  │   ├── layout.tsx
  │   └── loading.tsx
  ├── components/        # Reusable components
  │   ├── shared/        # Shared/common components
  │   └── [feature]/     # Feature-specific components
  ├── api/               # API route handlers
  │   └── [route]/
  │       └── route.ts
  └── globals.css

lib/
  ├── hooks/             # Custom React hooks
  ├── utils/             # Utility functions
  ├── types/             # TypeScript types
  ├── validation/        # Zod schemas
  └── [feature]/         # Feature-specific logic
```

### Component Organization
- **Shared Components**: `app/components/shared/`
  - Buttons, Inputs, Cards, Modals, etc.
  - Should be generic and reusable
- **Feature Components**: `app/components/[feature]/`
  - Feature-specific components
  - Can import from shared components

## Code Generation Rules

### When Creating Components
1. **Check for existing shared components first**
2. If creating a new shared component:
   - Place in `app/components/shared/`
   - Make it generic and reusable
   - Add TypeScript types for all props
   - Add JSDoc comments
   - Export as named export
3. If creating a feature component:
   - Place in `app/components/[feature]/`
   - Import shared components when possible
   - Keep it focused on the feature

### Component Template
```tsx
import { type ComponentProps } from 'react'

/**
 * [Component description]
 * 
 * @example
 * ```tsx
 * <ComponentName prop1="value" />
 * ```
 */
export function ComponentName({
  prop1,
  ...props
}: ComponentNameProps) {
  return (
    <div {...props}>
      {/* Component content */}
    </div>
  )
}

export type ComponentNameProps = ComponentProps<'div'> & {
  prop1: string
}
```

### Server Component Template
```tsx
import { type Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Page Title',
  description: 'Page description',
}

export default async function Page() {
  // Data fetching
  const data = await fetchData()
  
  return (
    <div>
      {/* Server Component content */}
    </div>
  )
}
```

### Client Component Template
```tsx
'use client'

import { useState } from 'react'

export function ClientComponent() {
  const [state, setState] = useState()
  
  return (
    <div>
      {/* Client Component content */}
    </div>
  )
}
```

### Server Action Template
```tsx
'use server'

import { z } from 'zod'
import { revalidatePath } from 'next/cache'

const schema = z.object({
  // Define schema
})

export async function actionName(formData: FormData) {
  try {
    const validated = schema.parse({
      // Parse form data
    })
    
    // Perform action
    
    revalidatePath('/path')
    return { success: true }
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    }
  }
}
```

## Package Management

### Latest Packages (as of Next.js 16)
- `next`: ^16.0.0
- `react`: ^18.3.0
- `react-dom`: ^18.3.0
- `typescript`: ^5.7.0
- `tailwindcss`: ^3.3.3
- `zod`: ^3.23.8 (for validation)
- `@supabase/ssr`: ^0.7.0
- `@supabase/supabase-js`: ^2.45.0

### When Adding New Packages
- Always use the latest stable version
- Check compatibility with Next.js 16
- Prefer packages that support React Server Components
- Use `npm install` or `pnpm install` (check package manager in use)

## Import Conventions

### Import Order
1. React and Next.js imports
2. Third-party library imports
3. Internal imports (use `@/` alias)
4. Type imports (use `type` keyword)
5. Relative imports

### Example
```tsx
import { useState } from 'react'
import { type Metadata } from 'next'
import { z } from 'zod'

import { Button } from '@/app/components/shared/Button'
import { useAuth } from '@/lib/hooks/useAuth'

import type { User } from '@/lib/types/auth'
```

## Common Patterns

### Data Fetching Pattern
```tsx
// Server Component
export default async function Page() {
  const data = await fetch('...', {
    next: { revalidate: 3600 } // ISR
  }).then(res => res.json())
  
  return <DataDisplay data={data} />
}
```

### Form with Server Action Pattern
```tsx
// Server Component
import { Form } from './Form'

export default function Page() {
  return <Form />
}

// Client Component (Form.tsx)
'use client'

import { useActionState } from 'react'
import { submitAction } from '@/lib/server-actions'

export function Form() {
  const [state, formAction] = useActionState(submitAction, null)
  
  return (
    <form action={formAction}>
      {/* Form fields */}
    </form>
  )
}
```

### Loading State Pattern
```tsx
// app/[route]/loading.tsx
export default function Loading() {
  return <div>Loading...</div>
}
```

### Error Boundary Pattern
```tsx
// app/[route]/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={reset}>Try again</button>
    </div>
  )
}
```

## Testing Considerations
- Write tests for Server Actions
- Test Server Components with async rendering
- Test Client Components with React Testing Library
- Use proper mocking for external dependencies

## Accessibility
- Use semantic HTML elements
- Add proper ARIA labels when needed
- Ensure keyboard navigation works
- Maintain proper heading hierarchy
- Use proper form labels
- Ensure color contrast meets WCAG standards

## Code Quality
- Use ESLint with Next.js config
- Format code with Prettier (if configured)
- Write self-documenting code
- Add JSDoc comments for complex functions
- Keep functions small and focused
- Avoid deep nesting (max 3-4 levels)

## Git Conventions
- Use descriptive commit messages
- Keep commits focused and atomic
- Use conventional commit format when possible

## Important Reminders
1. **Always check `app/components/shared/` before creating new components**
2. **Use Server Components by default - only add `'use client'` when necessary**
3. **Prefer Server Actions over API routes for mutations**
4. **Use TypeScript strictly - avoid `any`**
5. **Follow the component/module-first organization approach**
6. **Keep components small, focused, and reusable**
7. **Use Tailwind CSS for styling**
8. **Implement proper error handling and loading states**
9. **Optimize for performance (images, fonts, code splitting)**
10. **Validate all inputs with Zod**

