# Next.js 16 Cursor Rules (Samvera)

## Project Overview
This is a Next.js 16 application using the App Router, TypeScript, Tailwind CSS, Supabase, and Firebase for a multi-role (admin, principal, teacher, guardian) school platform.  
Follow these rules for all code generation and modifications so they stay consistent with the existing `app/`, `app/components/`, `lib/handlers/`, `lib/services/`, and `lib/validation/` structure.

## Core Principles

### 1. Feature‑First, Handler‑Centric Architecture
- **Always** organize code by feature/domain (announcements, attendance, menus, messages, dashboards, etc.) before type.
- Keep domain logic in `lib/handlers/` and `lib/services/`, not in React components or route handlers.
- Use `lib/validation/` + `lib/types/` for shared schemas and types per feature.
- Treat `lib/server-actions.ts` as the main entry point for dashboard/server actions, delegating to handlers.

### 2. Components & Colocation
- Use `app/(app)/dashboard/**` for role-specific dashboard routes and pages.
- Use `app/components/` for reusable UI and feature components; colocate per feature:
  - `app/components/shared/` for generic building blocks (buttons, inputs, layout, skeletons, etc.).
  - `app/components/attendance/`, `app/components/principal/`, etc. for feature- or role-specific UI.
- Prefer colocation: keep a feature’s components, types, validation, handlers, and services close by within `lib/**` and `app/components/**`.

### 3. Shared Components
- **Always** check `app/components/shared/` before creating a new button, input, layout element, modal, or card.
- Shared components must be:
  - Generic and reusable across roles (teacher, principal, guardian, admin).
  - Well-typed with TypeScript and accept `className` for Tailwind extension.
  - Documented with JSDoc comments when behavior is non-trivial.
- If a pattern is used in more than one dashboard route, extract it into `app/components/shared/` (or a clearly named subfolder) rather than duplicating.

## Next.js 16 & Routing

### App Router Structure
- Use **Server Components by default** for `page.tsx`, `layout.tsx`, and most dashboard routes under:
  - `app/(app)/dashboard/**`
  - `app/(auth)/**`
  - `app/invite/**`
- Only mark components with `'use client'` when they:
  - Use React hooks (`useState`, `useEffect`, `useContext`, etc.).
  - Use browser APIs (e.g. `window`, `localStorage`).
  - Handle DOM events (`onClick`, `onChange`, etc.).
  - Integrate with client-only SDKs (Firebase messaging, etc.).
- Use route groups as they exist:
  - Auth routes in `app/(auth)/signin`, `app/(auth)/callback`.
  - Main app experiences in `app/(app)/dashboard/...`.

### API Routes vs Server Actions
- **Default to API routes** (`app/api/**/route.ts`) for all new backend behavior unless a task explicitly asks for a Server Action.
- Use `app/api/**/route.ts` for:
  - Dashboard mutations initiated from UI (announcements, menus, notifications, events, etc.).
  - Integrations with external services or webhooks.
  - Endpoints consumed by non-Next.js clients.
  - Batched/background operations not tied to a single form submit.
- Use **Server Actions** (in `lib/server-actions.ts` or colocated `actions.ts`) **only when explicitly requested**, or when you are modifying an existing server action flow.
- In both API routes and Server Actions, always call into `lib/handlers/**` and `lib/services/**` to avoid duplicating business logic.

### File Naming Conventions
- Routes: `page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx`, `not-found.tsx`.
- API route handlers: `app/api/[route]/route.ts`.
- Components: `ComponentName.tsx` (PascalCase).
- Hooks: `useSomething.ts` in `lib/hooks/`.
- Validation: `[feature].ts` in `lib/validation/`.
- Types: `[feature].ts` in `lib/types/`.
- Handlers: `[feature]_handler.ts` or similar in `lib/handlers/`.
- Services: `[feature].ts` in `lib/services/`.

## Auth, Roles & Security

### Auth & Context
- Use the existing auth utilities instead of rolling your own:
  - `lib/auth.ts` and `lib/auth-context.tsx` for Supabase auth and React auth context.
  - `lib/server-helpers.ts` (`getRequestAuthContext`, `MissingOrgIdError`, etc.) to get the current user and org.
- Do not access Supabase directly in components or API routes; go through:
  - `lib/supabaseServer.ts` or `lib/supabaseClient.ts` where appropriate.
  - `supabaseAdmin` for server-side admin actions (already configured in `lib/supabaseClient.ts`).

### Role‑Based Access
- Use `SamveraRole` and `UserMetadata` from `lib/types/auth.ts` for role and metadata typing.
- In **server actions** and **API routes**, enforce access via `getRequestAuthContext`:
  - Always specify `allowedRoles` and `requireOrg` as appropriate.
  - Do not read `user.user_metadata` directly when a helper already exists for that behavior.
- For role switching and permission checks:
  - Use the helpers in `lib/server-actions.ts` (`hasPermission`, `hasAnyPermission`, `hasMinimumPermission`, `switchUserRole`).
  - When adding new role-sensitive flows, follow the pattern used for dashboards and announcements in `lib/server-actions.ts`.

### Security Rules
- Never expose Supabase admin credentials or server secrets to Client Components.
- Validate **all** user inputs (including URL params and query) with Zod schemas in `lib/validation/**`.
- Always sanitize or validate any user-provided text that might be displayed back in the UI.
- Use RLS and database policies (see `db/rls_policies.sql`) rather than trusting client-side checks.

## Directory & Module Organization

### `app/` Directory
```text
app/
  layout.tsx
  page.tsx
  globals.css

  (app)/
    dashboard/
      page.tsx
      add-announcement/
      add-guardian/
      add-menu/
      add-story/
      add-student/
      admin/
      announcements/
      attendance/
      edit-story/
      guardians/
      link-student/
      menus/
      menus-list/
      menus-view/
      notifications/
      parent/
      principal/
      stories/
      teacher/

  (auth)/
    signin/
    callback/

  api/
    [feature]/
      route.ts

  auth/
    callback-guardian/
    callback-staff/

  invite/
    accept-guardian/
    accept-staff/
```

### `app/components/` Directory
- **Shared**: `app/components/shared/**` (buttons, inputs, layout wrappers, modals, skeletons, common UI).
- **Feature/role specific** (examples, not exhaustive):
  - `app/components/attendance/**`
  - `app/components/principal/**`
  - `app/components/loading-skeletons/**`
  - Other top-level components like `AdminDashboard`, `ParentDashboard`, `Navbar`, `ServerRoleGuard`, `ProfileSwitcher`, etc.
- When adding new feature UI:
  - If it is dashboard-only and not generic, prefer `app/components/[feature]/`.
  - If it is generic or reused in multiple features (e.g. a modal, table wrapper, badge), prefer `app/components/shared/`.

### `lib/` Directory
- **Auth & Contexts**
  - `lib/auth.ts`, `lib/auth-context.tsx`, `lib/auth-errors.ts`
  - `lib/contexts/LanguageContext.tsx`, `lib/contexts/ThemeContext.tsx`
- **Core Data & Integration**
  - `lib/supabaseClient.ts`, `lib/supabaseServer.ts`
  - `lib/firebase/admin.ts`, `lib/firebase/client.ts`
  - `lib/email-service.ts`, `lib/email-templates.ts`
  - `lib/cacheConfig.ts`, `lib/server-helpers.ts`
  - `lib/translations/**`
- **Domain Logic**
  - `lib/handlers/**` for feature-specific data access and business rules.
  - `lib/services/**` for cross-cutting concerns (notifications, device tokens, attendance, push notifications).
  - `lib/utils/**` for pure helpers (`studentUtils.ts`, etc.).
  - `lib/types/**` for feature-specific types (announcements, attendance, auth, menus, messages, dashboards, health-logs).
  - `lib/validation/**` for Zod schemas per feature (announcements, attendance, menus, orgs, photos, classes).
  - `lib/server-actions.ts` as the central server action entrypoint delegating into handlers/services.

When adding a new feature, follow this pattern:
- **Types** → `lib/types/[feature].ts`
- **Validation** → `lib/validation/[feature].ts`
- **Handlers** → `lib/handlers/[feature]_handler.ts` (or similar).
- **Services** → `lib/services/[feature].ts` (only if it’s cross-cutting/infrastructural).
- **UI** → `app/components/[feature]/` and/or `app/components/shared/`.
- **Routes** → `app/(app)/dashboard/[feature]/page.tsx` (for dashboard) or `app/api/[feature]/route.ts` (for API).

## Server Actions & Handlers

### Pattern
- All server actions in `lib/server-actions.ts`:
  - Start with `'use server';` at the top of the file.
  - Call `getRequestAuthContext` to enforce auth, roles, and optionally org membership.
  - Use `supabaseAdmin` to interact with Supabase, never raw clients directly from components.
  - Delegate business logic to `lib/handlers/**` (e.g. `handleCreateAnnouncement`, `handleCreateMenu`, `handleCreateEvent`).
  - Use `revalidatePath` to keep dashboard and detail routes in sync after mutations.
- When adding a new server action:
  1. Define or reuse Zod schemas in `lib/validation/**`.
  2. Implement a handler in `lib/handlers/**` doing the heavy lifting.
  3. Add a thin server action in `lib/server-actions.ts` that:
     - Authenticates and checks roles.
     - Calls the handler and handles errors.
     - Revalidates all relevant paths (e.g. `/dashboard`, `/dashboard/[feature]`).

### Example Skeleton
```tsx
'use server';

import { revalidatePath } from 'next/cache';
import { z } from 'zod';

import { getRequestAuthContext } from './server-helpers';
import { supabaseAdmin } from './supabaseClient';
import { handleCreateSomething } from './handlers/server_actions_handler';
import { createSomethingSchema } from './validation';

export async function createSomething(data: z.infer<typeof createSomethingSchema>) {
  const { user } = await getRequestAuthContext({
    allowedRoles: ['teacher', 'principal', 'admin'],
    requireOrg: true,
  });

  if (!supabaseAdmin) {
    throw new Error('Admin client not configured');
  }

  const result = await handleCreateSomething(user, supabaseAdmin, data);

  revalidatePath('/dashboard');
  revalidatePath('/dashboard/something');
  return result;
}
```

## TypeScript & Validation

### TypeScript
- Use strict typing everywhere; avoid `any`. Use `unknown` only when truly necessary and narrow it.
- Prefer `interface` for object shapes; use `type` for unions, intersections, and utility types.
- Export feature-specific types from `lib/types/[feature].ts` and reuse them across:
  - Handlers (`lib/handlers/**`)
  - Services (`lib/services/**`)
  - Components (`app/components/**`)
  - API routes (`app/api/**/route.ts`)

### Zod & Validation
- Every mutation or external input path must be backed by a Zod schema:
  - Store schemas in `lib/validation/[feature].ts`.
  - Reuse schemas between server actions, handlers, and API routes.
- Parse at the edge:
  - For server actions, parse the input directly using the schema (or use types derived via `z.infer`).
  - For API routes, validate `req.json()` or `req.body` with the correct schema before any DB calls.

## Styling & UI

### Design System
- **ALWAYS** follow the design system specifications defined in `design/principal_dashboard_json_design_system.json` when creating or modifying UI components.
- Before creating any new UI component, review the design system for:
  - **Color palette**: Use the specified colors (mint `#C5E8D5`, pale blue `#D4E4F7`, pale yellow `#FFD966`, pale peach `#F5D5C8`, input fill `#F5FFF7`, input stroke `#D8EBD8`, etc.).
  - **Typography**: Follow font sizes, weights, and line heights as specified (heading1: 32px, heading2: 24px, heading3: 20px, body: 16px, etc.).
  - **Spacing**: Use the 8px base unit scale (xs: 8px, sm: 16px, md: 24px, lg: 32px, xl: 48px, 2xl: 64px).
  - **Border radius**: Apply appropriate border radius values (sm: 8px, md: 12px, lg: 16px, xl: 24px, full: 9999px).
  - **Shadows**: Use the specified shadow values for cards and elevated elements.
  - **Component patterns**: Follow the structure and styling guidelines for cards, navigation, stat displays, search bars, text inputs, textareas, content sections, and list displays.
  - **Layout patterns**: Adhere to the dashboard grid structure, sidebar layout (280px width, 24px padding, 24px border radius), and main content area specifications.
  - **Interaction states**: Implement hover, active, and disabled states as defined in the design system.
- Map design system values to Tailwind classes (e.g., use `rounded-xl` for 24px border radius, `p-6` for 24px padding, etc.).
- When the design system specifies exact values, use those values rather than arbitrary Tailwind classes.
- Maintain consistency with the design principles: spaciousness, softness, hierarchy, color usage, minimalism, and consistency.

### Tailwind CSS
- Use Tailwind utility classes for styling; avoid custom CSS unless required.
- Use responsive classes (e.g. `sm:`, `md:`, `lg:`) to maintain mobile-first design.
- Prefer composition via `className` and shared primitives (e.g. buttons, cards) in `app/components/shared/`.
- When design system values don't map directly to Tailwind defaults, use arbitrary values (e.g. `bg-[#C5E8D5]` for mint color, `rounded-[24px]` for xl border radius).

### Layout & Skeletons
- Use `LayoutWrapper`, `Navbar`, `ThemeToggle`, and other layout components rather than re-inventing layout logic.
- For loading states:
  - Prefer dedicated skeleton components in `app/components/loading-skeletons/` over inline spinners when loading large sections.
  - Create `loading.tsx` files for long-running dashboard pages.

## Performance
- Use `next/image` for all images.
- Use `next/link` for navigation between pages.
- Keep heavy or client-only UI in isolated client components and use dynamic imports (`next/dynamic`) when necessary.
- Use React Server Components for data-heavy or role-gated dashboard pages to keep bundles small.
- Use appropriate caching strategies (`next: { revalidate }` or `cache: 'no-store'`) based on data freshness requirements.

## Testing & Reliability
- Prefer testing server actions and handlers over UI when validating business logic.
- When adding a new complex handler in `lib/handlers/**`, design it so it can be tested independently of Next.js.
- For client components, use React Testing Library to test UI behaviors and interactions (if/when test harness exists).

## Accessibility
- Use semantic HTML (e.g. `button`, `nav`, `main`, `section`, `header`, `footer`).
- Ensure all interactive elements are keyboard accessible and have visible focus states.
- Always provide labels for form elements and ARIA attributes when necessary.
- Maintain a consistent heading hierarchy across dashboard pages.

## Import Conventions

### Import Order
1. React and Next.js imports.
2. Third-party library imports.
3. Internal imports using the `@/` alias (if available) or from `lib/` and `app/components/`.
4. Type-only imports using the `type` keyword.
5. Relative imports (`./` and `../`).

### Example
```tsx
import { useState } from 'react';
import { type Metadata } from 'next';
import { z } from 'zod';

import { Button } from '@/app/components/shared/Button';
import { useAuth } from '@/lib/hooks/useAuth';

import type { User } from '@/lib/types/auth';
```

## Git & Code Quality
- Use ESLint with the Next.js config and keep the codebase formatted (Prettier, if configured).
- Keep functions small and focused; prefer extracting helpers to `lib/utils/**` or `lib/handlers/**`.
- Use descriptive, atomic commits; follow conventional commit format when possible.
- Add JSDoc for complex components, hooks, and handlers, especially those in `lib/services/` and `lib/handlers/`.

## Important Reminders
1. **Always follow the design system** in `design/principal_dashboard_json_design_system.json` when creating or modifying UI components.
2. **Reuse existing patterns** in `lib/server-actions.ts`, `lib/handlers/`, `lib/services/`, and `lib/validation/` when adding new features.
3. **Centralize business logic** in handlers/services, not in components or route handlers.
4. **Use Server Components by default**, and `'use client'` only when needed.
5. **Validate all inbound data** with Zod schemas from `lib/validation/**`.
6. **Enforce roles and org membership** with `getRequestAuthContext` for every protected operation.
7. **Keep components small, focused, and reusable**, and prefer `app/components/shared/` when patterns repeat.
8. **Use Tailwind CSS** and shared layout components for consistent, responsive UI, mapping design system values to Tailwind classes.
9. **Leverage Supabase and Firebase helpers** instead of adding new clients or ad‑hoc integrations.
10. **Keep routes, handlers, and actions in sync** by revalidating relevant dashboard paths after mutations.
11. **Never commit secrets**; always use environment variables and keep security and RLS policies in mind.


